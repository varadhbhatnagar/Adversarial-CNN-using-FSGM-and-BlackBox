# -*- coding: utf-8 -*-
"""BB-mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xNkMuUeWIERm6PnR2c5erVthqNiws_CN
"""

!pip install git+https://github.com/tensorflow/cleverhans.git#egg=cleverhans

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import functools
import logging
import numpy as np
from six.moves import xrange
import tensorflow as tf
import random
import matplotlib.pyplot as plt

from cleverhans.attacks import FastGradientMethod
from cleverhans.utils_tf import jacobian_graph, jacobian_augmentation
from cleverhans.compat import flags
from cleverhans.dataset import MNIST
from cleverhans.initializers import HeReLuNormalInitializer
from cleverhans.loss import CrossEntropy
from cleverhans.model import Model
from cleverhans.train import train
from cleverhans.utils import set_log_level
from cleverhans.utils import TemporaryLogLevel
from cleverhans.utils import to_categorical
from cleverhans.utils_tf import model_eval, batch_eval

from cleverhans.model_zoo.basic_cnn import ModelBasicCNN

from tensorflow.python.util import deprecation
deprecation._PRINT_DEPRECATION_WARNINGS = False
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

import warnings 
warnings.filterwarnings('ignore')

x = None
y = None
sess = None

'''
To show the plots
:param x : sample input array
:param y : sample output array
'''
def show_plot(x, y):

  for k in range(20):
    print("Plot : ", k+1)
    i = random.randint(1,x.shape[0]+1)
    print("Input Sample Number : ", i)
    pixels = x[i,:,:,0]
    plt.imshow(pixels)
    plt.show()
    print(y[i])
    #print("Output : " , np.where(y[i]==1)[0][0])
    #print("--------------------------------------------")


'''
Intializing the tensorlow
:param img_rows: rows in the image
:param img_cols: columns in the image
:param nchannels : number of channels for x
:param nb_classes : number of classes of y
'''
def initialize_tensorflow(img_rows, img_cols, nchannels, nb_classes):
    global x , y, sess

    tf.set_random_seed(1234)
    set_log_level(logging.DEBUG)

    sess = tf.Session()

    x = tf.placeholder(tf.float32, shape=(None, img_rows, img_cols,
                                          nchannels))
    y = tf.placeholder(tf.float32, shape=(None, nb_classes))



'''
Substitute DNN Training : for oracle ̃O,a maximum number maxρ of substitute 
training epochs, a substitute architecture F, and an initial training set S0

:param  bbox_preds : predictions of blackbox
:param x_sub : initial subsitute data
:param y_sub : initial subsitute labels
:param nb_classes : number of classes for the ouput
:param nb_epochs_s : number of epochs for subsitute training
:param batch_size : training batch sizes
:param learning_rate : training learning rate
:param data_aug : number of times the subs training is augmented
:param lmbda : a hpyer parameter for data augmentation
:param aug_batch_size : batch size of augmentation
:param rng : range
:param img_cols : columns in image
:param nchannels : channels used
'''

def train_substitute(bbox_preds, x_sub, y_sub, nb_classes,
              nb_epochs_s, batch_size, lr, data_aug, lmbda,
              aug_batch_size, rng, img_rows=28, img_cols=28,
              nchannels=1):
    model_sub = ModelSubstitute('model_s', nb_classes)
    preds_sub = model_sub.get_logits(x)
    loss_sub = CrossEntropy(model_sub, smoothing=0)

    print("Defined TensorFlow model graph for the substitute.")

    grads = jacobian_graph(preds_sub, x, nb_classes)

    for i in xrange(data_aug):
        print("Substitute training epoch #" + str(i))
        train_params = {
            'nb_epochs': nb_epochs_s,
            'batch_size': batch_size,
            'learning_rate': lr
        }
        with TemporaryLogLevel(logging.WARNING, "cleverhans.utils.tf"):
            train(sess, loss_sub, x_sub, to_categorical(y_sub, nb_classes),
                  init_all=False, args=train_params, rng=rng,
                  var_list=model_sub.get_params())

        if i < data_aug - 1:
            print("Augmenting substitute training data.")
            lmbda_coef = 2 * int(int(i / 3) != 0) - 1
            x_sub = jacobian_augmentation(sess, x, x_sub, y_sub, grads,
                                          lmbda_coef * lmbda, aug_batch_size)

            print("Labeling substitute training data.")
            y_sub = np.hstack([y_sub, y_sub])
            x_sub_prev = x_sub[int(len(x_sub) / 2):]
            eval_params = {'batch_size': batch_size}
            bbox_val = batch_eval(sess, [x], [bbox_preds], [x_sub_prev],
                                  args=eval_params)[0]

            y_sub[int(len(x_sub) / 2):] = np.argmax(bbox_val, axis=1)
    show_plot(x_sub, y_sub)
    return model_sub, preds_sub, x_sub, y_sub

'''
the  attacker  uses substitute network F to craft adversarial samples, 
which are then misclassified by oracle O due to the transferability of 
adversarial samples.
:param Model : inherits from Model class
'''
class ModelSubstitute(Model):
  def __init__(self, scope, nb_classes, nb_filters=200, **kwargs):
    del kwargs
    Model.__init__(self, scope, nb_classes, locals())
    self.nb_filters = nb_filters

  def fprop(self, x, **kwargs):
    del kwargs
    my_dense = functools.partial(
        tf.layers.dense, kernel_initializer=HeReLuNormalInitializer)
    with tf.variable_scope(self.scope, reuse=tf.AUTO_REUSE):
      y = tf.layers.flatten(x)
      y = my_dense(y, self.nb_filters, activation=tf.nn.relu)
      y = my_dense(y, self.nb_filters, activation=tf.nn.relu)
      logits = my_dense(y, self.nb_classes)
      return {self.O_LOGITS: logits,
              self.O_PROBS: tf.nn.softmax(logits=logits)}

'''
Oracle Model
Only labels of this model is accessible
This can be some remote model too
'''
class OracleCNN:
    def __init__(self, nb_epochs, batch_size, lr, eps = 0.3, 
                 clip_min=0, clip_max=1):
        self.x_train = None
        self.y_train = None
        self.x_test = None
        self.y_test = None
        self.range = np.random.RandomState([2019, 11, 25])
        self.model = None
        self.preds = None
        self.loss = None
        self.img_rows = None
        self.img_cols = None
        self.nchannels = None
        self.nb_classes = None
        self.preds_adv = None
        self.x_sub = None
        self.y_sub = None

        self.eval_params = {'batch_size': batch_size}

        self.train_params = {
            'nb_epochs': nb_epochs,
            'batch_size': batch_size,
            'learning_rate': lr
        }

        self.fgsm_params = {
            'eps': eps,
            'clip_min': clip_min,
            'clip_max': clip_max,
            'ord': np.inf
        }



    def get_data(self, train_start, train_end, test_start, test_end, s0):
        mnist = MNIST(train_start=train_start, train_end=train_end,
                      test_start=test_start, test_end=test_end)
        self.x_train, self.y_train = mnist.get_set('train')
        self.x_test, self.y_test = mnist.get_set('test')
        self.img_rows, self.img_cols, self.nchannels = self.x_train.shape[1:4]
        self.nb_classes = self.y_train.shape[1]
        #print('^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^')
        #print(self.x_train.shape, self.y_train.shape, self.x_test.shape, self.y_test.shape)
        self.x_sub = self.x_test[:s0]
        self.y_sub = np.argmax(self.y_test[:s0], axis=1)

        self.x_test = self.x_test[s0:]
        self.y_test = self.y_test[s0:]
        #print(self.y_test)

    '''
    Training the model which will used as oracel in for case
    '''
    def prepblackbox(self, nb_filters):
        model = ModelBasicCNN('model1', self.nb_classes, nb_filters)
        loss = CrossEntropy(model, smoothing=0.1)
        predictions = model.get_logits(x)
        print("Defined TensorFlow model graph.")

        train(sess, loss, self.x_train, self.y_train, args=self.train_params, 
              rng=self.range)

        eval_params = {'batch_size': batch_size}
        accuracy = model_eval(sess, x, y, predictions, self.x_test, self.y_test,
                              args=eval_params)
        print('Test accuracy of black-box on legitimate test '
              'examples: ' + str(accuracy))

        return model, predictions, accuracy

    def evaluate(self, preds_sub):
        return model_eval(sess, x, y, preds_sub, self.x_test, self.y_test,
                          args=self.eval_params)

    def testing(self, model_sub):
        fgsm = FastGradientMethod(model_sub, sess=sess )
        x_adv_sub = fgsm.generate(x, **self.fgsm_params)
        #print("*****************************************")
        #print(type(x_adv_sub))
        #print(tf.argmax(x_adv_sub, axis=-1))
        accuracy = model_eval(sess, x, y, model.get_logits(x_adv_sub),
                              self.x_test, self.y_test, args=self.eval_params)
        print('Test accuracy of oracle on adversarial examples generated '
              'using the substitute: ' + str(accuracy))
        return accuracy
        
        
if __name__ == '__main__':
    nb_epochs = 6
    nb_epochs_s = 10
    batch_size = 128
    lr = 0.001
    train_start = 0
    train_end = 60000
    test_start = 0
    test_end = 10000
    s0 = 150
    nb_filters = 64
    data_aug = 5
    lmbda = 0.1
    aug_batch_size = 512
    accuracies = {}

    oracleObj = OracleCNN(nb_epochs, batch_size, lr)
    oracleObj.get_data(train_start, train_end, test_start, test_end, s0)
    initialize_tensorflow(oracleObj.img_rows, oracleObj.img_cols, oracleObj.
                          nchannels, oracleObj.nb_classes)
    model, bbox_preds, accuracies['black_box'] = oracleObj.prepblackbox(nb_filters)
    model_sub, preds_sub, x_sub, y_sub = train_substitute(bbox_preds, 
                    oracleObj.x_sub, oracleObj.y_sub, oracleObj.nb_classes,
                     nb_epochs_s, batch_size, lr,data_aug, lmbda,
                      aug_batch_size, oracleObj.range, oracleObj.img_rows, 
                     oracleObj.img_cols, oracleObj.nchannels)

    accuracies['sub_model'] = oracleObj.evaluate(preds_sub)
    accuracies['bbox_on_sub_adv_ex'] = oracleObj.testing(model_sub)
    #print("+++++++++++++++++++++++++++++++")
    #print(oracleObj.x_train.shape)
    #print(oracleObj.x_train.shape)
    ##print(oracleObj.x_test.shape)
    #print(oracleObj.y_test.shape)
    #print("+++++++++++++++++++++++++++++++")
    #show_plot(oracleObj.x_train, oracleObj.y_train)
    print(accuracies)